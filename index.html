<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Golden Geometric Christmas 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; touch-action: none; }
        .font-serif-custom { font-family: 'Playfair Display', serif; }
        * { -webkit-tap-highlight-color: transparent; user-select: none; -webkit-user-select: none; }
        
        #loader { position: fixed; inset: 0; background: #000; z-index: 50; display: flex; align-items: center; justify-content: center; transition: opacity 0.5s; pointer-events: none; }
        #loader.hidden { opacity: 0; }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top-color: #D4AF37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        #error-log { display: none; position: fixed; top: 0; left: 0; width: 100%; background: rgba(100,0,0,0.8); color: white; padding: 10px; z-index: 9999; font-family: monospace; font-size: 12px; white-space: pre-wrap; }
    </style>
    <!-- Import Map: STRICTLY LOCKED VERSIONS -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.14?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "lucide-react": "https://esm.sh/lucide-react@0.300.0?external=react,react-dom",
    "three/examples/jsm/geometries/TextGeometry": "https://esm.sh/three@0.160.0/examples/jsm/geometries/TextGeometry?external=three",
    "three/examples/jsm/loaders/FontLoader": "https://esm.sh/three@0.160.0/examples/jsm/loaders/FontLoader?external=three",
    "react-dom/": "https://esm.sh/react-dom@^19.2.1/",
    "react/": "https://esm.sh/react@^19.2.1/",
    "three/": "https://esm.sh/three@^0.182.0/"
  }
}
</script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="loader"><div class="spinner"></div></div>
    <div id="error-log"></div>
    <div id="root"></div>

    <script>
        window.onerror = function(msg, url, line, col, error) {
            const el = document.getElementById('error-log');
            if(el) {
                el.style.display = 'block';
                el.innerText += `Error: ${msg}\nLine: ${line}\n\n`;
            }
            document.getElementById('loader').classList.add('hidden');
            return false;
        };
    </script>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
        import React, { useState, useEffect, useRef, useMemo, Suspense } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useLoader } from '@react-three/fiber';
        import { OrbitControls, Environment, ContactShadows, Stars, Sparkles } from '@react-three/drei';
        import { EffectComposer, Bloom } from '@react-three/postprocessing';
        import { Volume2, VolumeX } from 'lucide-react';
        import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry';
        import { FontLoader, Font } from 'three/examples/jsm/loaders/FontLoader';

        setTimeout(() => {
            const loader = document.getElementById('loader');
            if(loader) loader.classList.add('hidden');
        }, 1500);

        // --- CONSTANTS & CONFIG ---
        // Replacing Enum with Const Object to prevent ReferenceErrors
        const AppState = {
            TREE: 0,
            EXPLODED: 1,
            TEXT: 2
        };

        const TOTAL_PARTICLES = 6000;
        const SPHERE_COUNT = 3500; 
        const COLOR_GOLD = "#FFD700";
        const COLOR_RED = "#D41C2C";
        const COLOR_GREEN = "#1A5228";
        const COLOR_DEEP_GREEN = "#0F3015";
        const FONT_URL = 'https://threejs.org/examples/fonts/helvetiker_bold.typeface.json';
        const MUSIC_URL = 'https://cdn.pixabay.com/download/audio/2020/12/24/audio_3490795c64.mp3?filename=christmas-background-music-12828.mp3';
        const INTERACTION_SOUND_URL = 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_17a4c73171.mp3?filename=magic-glitter-6202.mp3';

        // --- UTILS ---
        const generateTreePositions = (count) => {
            const data = new Float32Array(count * 3);
            const height = 12;
            const maxRadius = 5;
            for (let i = 0; i < count; i++) {
                const yNorm = Math.pow(Math.random(), 0.8); 
                const y = 6 - (yNorm * height); 
                const r = yNorm * maxRadius * Math.sqrt(Math.random()); 
                const theta = i * 0.5 + Math.random() * Math.PI * 2; 
                data[i * 3] = r * Math.cos(theta);
                data[i * 3 + 1] = y;
                data[i * 3 + 2] = r * Math.sin(theta);
            }
            return data;
        };

        const generateExplosionPositions = (count) => {
            const data = new Float32Array(count * 3);
            const radius = 15;
            for (let i = 0; i < count; i++) {
                const r = radius * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                data[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                data[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                data[i * 3 + 2] = r * Math.cos(phi);
            }
            return data;
        };

        const analyzeGeometry = (geometry) => {
            const posAttribute = geometry.attributes.position;
            const faceCount = posAttribute.count / 3;
            const weights = new Float32Array(faceCount);
            let totalArea = 0;
            const vA = new THREE.Vector3(), vB = new THREE.Vector3(), vC = new THREE.Vector3();
            const tempVecA = new THREE.Vector3(), tempVecB = new THREE.Vector3();

            for (let i = 0; i < faceCount; i++) {
                vA.fromBufferAttribute(posAttribute, i * 3);
                vB.fromBufferAttribute(posAttribute, i * 3 + 1);
                vC.fromBufferAttribute(posAttribute, i * 3 + 2);
                tempVecA.subVectors(vB, vA);
                tempVecB.subVectors(vC, vA);
                tempVecA.cross(tempVecB);
                const area = 0.5 * tempVecA.length();
                totalArea += area;
                weights[i] = totalArea;
            }
            return { weights, totalArea, faceCount, posAttribute };
        };

        const samplePoint = (info, target, index) => {
            const r = Math.random() * info.totalArea;
            let lower = 0, upper = info.faceCount - 1, faceIndex = 0;
            while (lower <= upper) {
                const mid = Math.floor((lower + upper) / 2);
                if (info.weights[mid] < r) lower = mid + 1;
                else { upper = mid - 1; faceIndex = mid; }
            }
            const i0 = faceIndex * 3;
            const vA = new THREE.Vector3().fromBufferAttribute(info.posAttribute, i0);
            const vB = new THREE.Vector3().fromBufferAttribute(info.posAttribute, i0 + 1);
            const vC = new THREE.Vector3().fromBufferAttribute(info.posAttribute, i0 + 2);
            let r1 = Math.random(), r2 = Math.random();
            if (r1 + r2 > 1) { r1 = 1 - r1; r2 = 1 - r2; }
            const r3 = 1 - r1 - r2;
            target[index * 3] = vA.x * r1 + vB.x * r2 + vC.x * r3;
            target[index * 3 + 1] = vA.y * r1 + vB.y * r2 + vC.y * r3;
            target[index * 3 + 2] = vA.z * r1 + vB.z * r2 + vC.z * r3;
        }

        const generateTextPositions = (font, count) => {
            const geoTop = new TextGeometry('Dear Liana', { font, size: 1.3, depth: 0.04, curveSegments: 6, bevelEnabled: true, bevelThickness: 0.01, bevelSize: 0.005, bevelSegments: 2 });
            geoTop.center(); geoTop.translate(0, 1.2, 0);
            const geoBottom = new TextGeometry('MERRY CHRISTMAS', { font, size: 1.3, depth: 0.04, curveSegments: 6, bevelEnabled: true, bevelThickness: 0.01, bevelSize: 0.005, bevelSegments: 2 });
            geoBottom.center(); geoBottom.translate(0, -1.2, 0);
            const infoTop = analyzeGeometry(geoTop);
            const infoBottom = analyzeGeometry(geoBottom);
            const totalArea = infoTop.totalArea + infoBottom.totalArea;
            const data = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                if (Math.random() < (infoTop.totalArea / totalArea)) samplePoint(infoTop, data, i);
                else samplePoint(infoBottom, data, i);
            }
            return data;
        }

        // --- COMPONENTS ---
        const SpiralEffect = ({ appState }) => {
            const meshRef = useRef(null);
            const particles = useMemo(() => {
                const temp = [];
                for (let i = 0; i < 500; i++) {
                    temp.push({ yPhase: Math.random() * 14, speed: 0.2 + Math.random() * 0.4, radiusOffset: Math.random() * 1.0, anglePhase: Math.random() * Math.PI * 2, rotSpeed: 0.5 + Math.random() * 0.5, scale: 0.01 + Math.random() * 0.025 });
                }
                return temp;
            }, []);
            const dummy = new THREE.Object3D();
            useFrame((state) => {
                if (!meshRef.current) return;
                const time = state.clock.elapsedTime;
                let i = 0;
                for (const p of particles) {
                    const loopH = (p.yPhase + time * p.speed) % 14; 
                    let y = loopH - 7;
                    const hClamped = Math.max(-6, Math.min(6, y));
                    const baseRadius = ((6 - hClamped) / 12) * 6.5;
                    const r = baseRadius + 0.5 + p.radiusOffset;
                    const angle = p.anglePhase + time * p.rotSpeed;
                    dummy.position.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                    let s = p.scale;
                    if (y > 4) s *= Math.max(0, (7 - y) / 3);
                    if (y < -5) s *= Math.max(0, (y + 7) / 2);
                    if (appState !== AppState.TREE) s = 0;
                    else s *= (0.6 + 0.4 * Math.sin(time * 10 + i * 132));
                    dummy.scale.setScalar(s);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i++, dummy.matrix);
                }
                meshRef.current.instanceMatrix.needsUpdate = true;
            });
            return (
                <instancedMesh ref={meshRef} args={[undefined, undefined, 500]}>
                    <sphereGeometry args={[1, 6, 6]} />
                    <meshBasicMaterial color="#FFFFFF" transparent opacity={0.9} blending={THREE.AdditiveBlending} depthWrite={false} toneMapped={false} />
                </instancedMesh>
            );
        };

        const MagicParticles = ({ appState }) => {
            const font = useLoader(FontLoader, FONT_URL);
            const spheresRef = useRef(null);
            const cubesRef = useRef(null);
            const [targetPositions, setTargetPositions] = useState(null);
            const textStateStartTime = useRef(0);
            const isTransitioningToText = useRef(false);
            const currentScales = useRef({ sphere: 0.25, cube: 0.22 });
            const currentPositions = useRef(new Float32Array(TOTAL_PARTICLES * 3));

            const { treePos, explodePos, textPos } = useMemo(() => {
                if (!font) return { treePos: new Float32Array(), explodePos: new Float32Array(), textPos: new Float32Array() };
                return { treePos: generateTreePositions(TOTAL_PARTICLES), explodePos: generateExplosionPositions(TOTAL_PARTICLES), textPos: generateTextPositions(font, TOTAL_PARTICLES) };
            }, [font]);

            const colors = useMemo(() => {
                const cSpheres = new Float32Array(SPHERE_COUNT * 3);
                const cCubes = new Float32Array((TOTAL_PARTICLES - SPHERE_COUNT) * 3);
                const color = new THREE.Color();
                for (let i = 0; i < SPHERE_COUNT; i++) {
                    color.set(Math.random() > 0.3 ? COLOR_GOLD : COLOR_RED).offsetHSL(0, 0, (Math.random() - 0.5) * 0.1);
                    cSpheres[i * 3] = color.r; cSpheres[i * 3 + 1] = color.g; cSpheres[i * 3 + 2] = color.b;
                }
                for (let i = 0; i < TOTAL_PARTICLES - SPHERE_COUNT; i++) {
                    if (Math.random() > 0.5) color.set(COLOR_GOLD); else if (Math.random() > 0.5) color.set(COLOR_GREEN); else color.set(COLOR_DEEP_GREEN);
                    color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.1);
                    cCubes[i * 3] = color.r; cCubes[i * 3 + 1] = color.g; cCubes[i * 3 + 2] = color.b;
                }
                return { spheres: cSpheres, cubes: cCubes };
            }, []);

            useEffect(() => {
                if (!font) return;
                switch (appState) {
                    case AppState.TREE: setTargetPositions(treePos); break;
                    case AppState.EXPLODED: setTargetPositions(explodePos); break;
                    case AppState.TEXT: setTargetPositions(textPos); isTransitioningToText.current = true; break;
                }
            }, [appState, font, treePos, explodePos, textPos]);

            useEffect(() => {
                if (treePos.length > 0 && currentPositions.current[0] === 0) currentPositions.current.set(treePos);
            }, [treePos]);

            useFrame((state, delta) => {
                if (!spheresRef.current || !cubesRef.current || !targetPositions) return;
                if (appState === AppState.TEXT && isTransitioningToText.current) {
                    textStateStartTime.current = state.clock.elapsedTime;
                    isTransitioningToText.current = false;
                }
                const dummy = new THREE.Object3D();
                const lerpSpeed = 4 * delta; 
                const time = state.clock.elapsedTime;
                const isText = appState === AppState.TEXT;

                currentScales.current.sphere = THREE.MathUtils.lerp(currentScales.current.sphere, isText ? 0.035 : 0.20, lerpSpeed);
                currentScales.current.cube = THREE.MathUtils.lerp(currentScales.current.cube, isText ? 0.03 : 0.18, lerpSpeed);

                let i = 0;
                const update = (idx, baseScale, mesh, instId, rotFact) => {
                    currentPositions.current[idx] = THREE.MathUtils.lerp(currentPositions.current[idx], targetPositions[idx], lerpSpeed);
                    currentPositions.current[idx+1] = THREE.MathUtils.lerp(currentPositions.current[idx+1], targetPositions[idx+1], lerpSpeed);
                    currentPositions.current[idx+2] = THREE.MathUtils.lerp(currentPositions.current[idx+2], targetPositions[idx+2], lerpSpeed);
                    let s = baseScale;
                    if (isText) {
                        const age = time - textStateStartTime.current;
                        const distToWave = Math.abs(targetPositions[idx] - (age * 12 - 15));
                        if (age < 3.5) s += Math.max(0, 1 - distToWave * 0.4) * (baseScale * 2.0);
                        s += Math.sin(time * 2 + targetPositions[idx] * 0.5) * (baseScale * 0.3);
                    } else {
                        s += Math.sin(time * 2 + i) * 0.05;
                    }
                    dummy.position.set(currentPositions.current[idx], currentPositions.current[idx+1], currentPositions.current[idx+2]);
                    dummy.rotation.set(time * rotFact + i, time * rotFact * 0.5 + i, 0);
                    dummy.scale.setScalar(s);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(instId, dummy.matrix);
                };

                for (let j = 0; j < SPHERE_COUNT; j++) { update(i * 3, currentScales.current.sphere, spheresRef.current, j, 0.2); i++; }
                for (let j = 0; j < TOTAL_PARTICLES - SPHERE_COUNT; j++) { update(i * 3, currentScales.current.cube, cubesRef.current, j, 0.5); i++; }
                spheresRef.current.instanceMatrix.needsUpdate = true;
                cubesRef.current.instanceMatrix.needsUpdate = true;
            });

            useEffect(() => {
                if (spheresRef.current && cubesRef.current) {
                    for (let i = 0; i < SPHERE_COUNT; i++) spheresRef.current.setColorAt(i, new THREE.Color(colors.spheres[i*3], colors.spheres[i*3+1], colors.spheres[i*3+2]));
                    for (let i = 0; i < TOTAL_PARTICLES - SPHERE_COUNT; i++) cubesRef.current.setColorAt(i, new THREE.Color(colors.cubes[i*3], colors.cubes[i*3+1], colors.cubes[i*3+2]));
                    spheresRef.current.instanceColor.needsUpdate = true;
                    cubesRef.current.instanceColor.needsUpdate = true;
                }
            }, [colors]);

            return (
                <group>
                    <instancedMesh ref={spheresRef} args={[undefined, undefined, SPHERE_COUNT]}>
                        <sphereGeometry args={[1, 16, 16]} />
                        <meshStandardMaterial metalness={0.9} roughness={0.15} envMapIntensity={1.5} />
                    </instancedMesh>
                    <instancedMesh ref={cubesRef} args={[undefined, undefined, TOTAL_PARTICLES - SPHERE_COUNT]}>
                        <boxGeometry args={[1, 1, 1]} />
                        <meshStandardMaterial metalness={0.8} roughness={0.2} envMapIntensity={1.2} />
                    </instancedMesh>
                </group>
            );
        };

        const TreeTopper = ({ appState }) => {
            const meshRef = useRef(null);
            const lightRef = useRef(null);
            const starGeometry = useMemo(() => {
                const shape = new THREE.Shape();
                for (let i = 0; i < 10; i++) {
                    const angle = (i * Math.PI) / 5 + Math.PI / 2;
                    const r = i % 2 === 0 ? 0.9 : 0.45;
                    if (i === 0) shape.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    else shape.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                }
                shape.closePath();
                const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.2, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.1, bevelSegments: 3 });
                geo.computeBoundingBox();
                geo.translate(0, 0, -(geo.boundingBox.max.z + geo.boundingBox.min.z) / 2);
                return geo;
            }, []);

            useFrame((state) => {
                if (!meshRef.current) return;
                const time = state.clock.elapsedTime;
                meshRef.current.rotation.y = time * 0.5;
                const targetScale = appState === AppState.TREE ? 1 : 0;
                meshRef.current.scale.setScalar(THREE.MathUtils.lerp(meshRef.current.scale.x, targetScale, 0.1));
                const twinkle = Math.sin(time * 3) * 0.3 + 0.1;
                if(lightRef.current) lightRef.current.intensity = THREE.MathUtils.lerp(lightRef.current.intensity, appState === AppState.TREE ? 2 + twinkle : 0, 0.1);
                if(meshRef.current.material) meshRef.current.material.emissiveIntensity = THREE.MathUtils.lerp(meshRef.current.material.emissiveIntensity, appState === AppState.TREE ? 0.6 + twinkle * 0.5 : 0, 0.1);
            });

            return (
                <group position={[0, 6.2, 0]}>
                    <mesh ref={meshRef} geometry={starGeometry}>
                        <meshStandardMaterial color="#FFD700" emissive="#FFD700" emissiveIntensity={0.6} metalness={1.0} roughness={0.2} />
                    </mesh>
                    <pointLight ref={lightRef} color="#FFD700" distance={8} decay={2} />
                </group>
            );
        };

        const Scene = ({ appState }) => {
            const groupRef = useRef(null);
            const lightRef = useRef(null);
            useFrame((state, delta) => {
                if(groupRef.current) groupRef.current.rotation.y += delta * 0.1;
                if(lightRef.current) {
                    const t = state.clock.elapsedTime * 0.5;
                    lightRef.current.position.set(Math.sin(t) * 12, Math.sin(t * 1.5) * 3 + 6, Math.cos(t) * 12);
                }
            });

            return (
                <Canvas camera={{ position: [0, 0, 20], fov: 45 }} dpr={[1, 2]} gl={{ toneMapping: THREE.ReinhardToneMapping, toneMappingExposure: 1.5 }}>
                    <color attach="background" args={['#050505']} />
                    <fog attach="fog" args={['#050505', 15, 35]} />
                    <ambientLight intensity={0.2} />
                    <pointLight position={[10, 10, 10]} intensity={1} color="#ffaa00" />
                    <spotLight position={[-10, 20, 10]} angle={0.3} penumbra={1} intensity={2} castShadow color="#ffeb3b" />
                    <pointLight ref={lightRef} intensity={3} distance={25} decay={2} color="#fffebb" />
                    
                    <group rotation-y={0}>
                         <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
                    </group>

                    <Suspense fallback={null}>
                        <group ref={groupRef}>
                            <MagicParticles appState={appState} />
                            <TreeTopper appState={appState} />
                            <SpiralEffect appState={appState} />
                        </group>
                    </Suspense>

                    <Sparkles count={200} scale={12} size={4} speed={0.4} opacity={0.5} color="#FFD700" />
                    <Sparkles count={150} scale={15} size={2} speed={0.8} opacity={0.8} color="#FFFFFF" />
                    <ContactShadows resolution={1024} scale={30} blur={2} opacity={0.5} far={10} color="#000000" />
                    <Environment preset="city" />
                    <EffectComposer enableNormalPass={false}>
                        <Bloom luminanceThreshold={0.8} mipmapBlur intensity={1.8} radius={0.4} />
                    </EffectComposer>
                    <OrbitControls enablePan={false} minPolarAngle={0} maxPolarAngle={Math.PI / 1.5} minDistance={5} maxDistance={30} makeDefault />
                </Canvas>
            );
        };

        const App = () => {
            const [appState, setAppState] = useState(AppState.TREE);
            const [isPlaying, setIsPlaying] = useState(false);
            const [hasInteracted, setHasInteracted] = useState(false);
            const dragStart = useRef({ x: 0, y: 0, time: 0 });
            const audioRef = useRef(null);
            const soundRef = useRef(null);

            useEffect(() => {
                audioRef.current = new Audio(MUSIC_URL);
                audioRef.current.loop = true;
                audioRef.current.volume = 0.4;
                soundRef.current = new Audio(INTERACTION_SOUND_URL);
                soundRef.current.volume = 0.6;
                audioRef.current.play().then(() => { setIsPlaying(true); setHasInteracted(true); }).catch(() => {});
                return () => { if(audioRef.current) audioRef.current.pause(); }
            }, []);

            const toggle = (e) => {
                e.stopPropagation();
                if(isPlaying) { audioRef.current.pause(); setIsPlaying(false); }
                else { audioRef.current.play(); setIsPlaying(true); }
            }

            const click = () => {
                if(!hasInteracted) { setHasInteracted(true); if(!isPlaying) audioRef.current.play().then(() => setIsPlaying(true)).catch(() => {}); }
                if(soundRef.current) { soundRef.current.currentTime = 0; soundRef.current.play().catch(() => {}); }
                setAppState(p => p === AppState.TREE ? AppState.EXPLODED : (p === AppState.EXPLODED ? AppState.TEXT : AppState.TREE));
            }

            return (
                <div className="w-full h-screen relative bg-black select-none touch-none" 
                     onPointerDown={e => dragStart.current = {x:e.clientX, y:e.clientY, t:Date.now()}} 
                     onPointerUp={e => { if(Math.hypot(e.clientX-dragStart.current.x, e.clientY-dragStart.current.y) < 20 && Date.now()-dragStart.current.t < 400) click(); }}>
                    <div className="absolute top-0 left-0 w-full z-10 pointer-events-none p-8 flex flex-col items-center">
                        <h1 className="text-4xl md:text-6xl text-[#D4AF37] font-serif-custom tracking-widest drop-shadow-[0_2px_10px_rgba(212,175,55,0.5)] text-center animate-pulse">MERRY CHRISTMAS</h1>
                        <p className="text-[#D4AF37] text-sm mt-4 opacity-70 font-serif-custom tracking-widest uppercase">
                            {appState === AppState.TREE && "Tap to Unwrap"}
                            {appState === AppState.EXPLODED && "Tap to Reveal"}
                            {appState === AppState.TEXT && "Tap to Rebuild"}
                        </p>
                    </div>
                    <button onClick={toggle} onPointerDown={e => e.stopPropagation()} className="absolute bottom-8 right-8 z-20 text-[#D4AF37] hover:text-white bg-white/10 backdrop-blur-md p-3 rounded-full border border-[#D4AF37]/30 pointer-events-auto">
                        {isPlaying ? <Volume2 size={24} /> : <VolumeX size={24} />}
                    </button>
                    <div className="w-full h-full cursor-pointer">
                        <Scene appState={appState} />
                    </div>
                    {!hasInteracted && !isPlaying && (
                        <div className="absolute inset-0 z-30 flex items-center justify-center bg-black/60 backdrop-blur-sm pointer-events-none">
                            <div className="text-[#D4AF37] animate-bounce">Tap anywhere to start</div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
